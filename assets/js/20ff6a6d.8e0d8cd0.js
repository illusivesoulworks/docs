"use strict";(self.webpackChunkillusivesoulworks_docs=self.webpackChunkillusivesoulworks_docs||[]).push([[9396],{8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>r});var i=s(6540);const n={},o=i.createContext(n);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),i.createElement(o.Provider,{value:t},e.children)}},9538:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"curios/items/assign-slots","title":"Assigning Slots","description":"A tutorial on how to assign items to slot types so that they can be equipped.","source":"@site/docs/curios/items/assign-slots.md","sourceDirName":"curios/items","slug":"/curios/items/assign-slots","permalink":"/curios/items/assign-slots","draft":false,"unlisted":false,"editUrl":"https://github.com/illusivesoulworks/docs/edit/main/docs/curios/items/assign-slots.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Creating a Curio","permalink":"/curios/items/curio-creation"},"next":{"title":"Rendering a Curio","permalink":"/curios/items/rendering-registry"}}');var n=s(4848),o=s(8453);const a={sidebar_position:4},r="Assigning Slots",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Item Tags",id:"item-tags",level:2},{value:"Example",id:"example",level:3},{value:"Removing Values",id:"removing-values",level:3},{value:"Validators",id:"validators",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"assigning-slots",children:"Assigning Slots"})}),"\n",(0,n.jsx)(t.p,{children:"A tutorial on how to assign items to slot types so that they can be equipped."}),"\n",(0,n.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["By default, items are assigned to slot types based on their item tags. For example, a ",(0,n.jsx)(t.code,{children:"ring"})," slot type would accept any\nitem that is part of the ",(0,n.jsx)(t.code,{children:"curios:ring"})," item tag. To find out more about item tags and their uses, please see the\n",(0,n.jsx)(t.a,{href:"https://minecraft.wiki/w/Tag#Items",children:"Minecraft wiki page"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["More broadly speaking, item assignments are based on the ",(0,n.jsx)(t.code,{children:"validators"})," field from each slot type, more information can be\nfound on the overview for ",(0,n.jsx)(t.a,{href:"/curios/slots/slot-register",children:"slot types"}),". Each of these validators is a predicate, a function\nthat takes a ",(0,n.jsx)(t.code,{children:"SlotContext"})," and ",(0,n.jsx)(t.code,{children:"ItemStack"})," and returns either true or false, and each predicate is registered through\nthe Curios API with a specific ",(0,n.jsx)(t.code,{children:"ResourceLocation"}),". The reason that the default is to accept relevant item tags is\nbecause, unless otherwise defined, each slot type uses an in-built validator called ",(0,n.jsx)(t.code,{children:"curios:tag"})," that tells it to accept\nany item that has its relevant tag."]}),"\n",(0,n.jsx)(t.h2,{id:"item-tags",children:"Item Tags"}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["Without defining validators, the default behavior is for slot types to accept any item that has its relevant item tag,\nwhich is always of the format ",(0,n.jsx)(t.code,{children:"curios:identifier"})," with the identifier of the slot type in the place of ",(0,n.jsx)(t.code,{children:"identifier"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The sole exception is the special ",(0,n.jsx)(t.code,{children:"curio"})," slot type, which is designed to accept any item that fits into any of the\nother slot types. Conversely, any item that is tagged with ",(0,n.jsx)(t.code,{children:"curios:curio"})," can be inserted into any slot type."]}),"\n",(0,n.jsxs)(t.p,{children:["Item tags are defined through datapacks. If a user or developer is unfamiliar with datapacks, it is recommended to read\nthrough the ",(0,n.jsx)(t.a,{href:"https://minecraft.wiki/w/Data_pack",children:"Minecraft wiki page"})," in order to understand the concept and structure\nbefore proceeding to the rest of this page."]}),"\n",(0,n.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,n.jsxs)(t.p,{children:["Inside the datapack, there should be a path of folders that looks like ",(0,n.jsx)(t.code,{children:"data/curios/tags/item"}),". At the end of this,\ninside the ",(0,n.jsx)(t.code,{children:"item"})," folder, is where the item tag data file should go. The name of the file should be the same as the\nname of the identifier of the slot type that the item(s) should go in and the format should be ",(0,n.jsx)(t.code,{children:".json"}),". For this\nexample, the ",(0,n.jsx)(t.code,{children:"ring"})," slot type will be used."]}),"\n",(0,n.jsxs)(t.p,{children:["The path should now look like ",(0,n.jsx)(t.code,{children:"data/curios/tags/item/ring.json"}),". The inside of the ",(0,n.jsx)(t.code,{children:"ring.json"})," file should look like:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "replace": false,\n  "values": []\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"replace"})," field should usually be set to false. It can be set to true instead if the items listed in this file are\nthe ",(0,n.jsx)(t.strong,{children:"only"})," items that should fit into the slot type, as it causes this file to overwrite any previous entries from\nlower-priority datapacks."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"values"})," field contains the list of items that should go into the slot. For this example, diamonds and emeralds\nwill be tagged:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "replace": false,\n  "values": ["minecraft:diamond", "minecraft:emerald"]\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Now all diamonds and all emeralds should have a tooltip that reads ",(0,n.jsx)(t.code,{children:"Slot: Ring"}),", which indicates that they can now go\ninto the ",(0,n.jsx)(t.code,{children:"ring"})," slot type if available."]}),"\n",(0,n.jsx)(t.h3,{id:"removing-values",children:"Removing Values"}),"\n",(0,n.jsxs)(t.p,{children:["Items can also be removed from item tags instead of added. This is useful for situations where it is necessary to move\nan item from one slot type to another and the original slot type should no longer accept the item. In this case,\nthere is a ",(0,n.jsx)(t.code,{children:"remove"})," field that can be used to list an array of items that should be removed from the slot type."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "replace": false,\n  "values": [],\n  "remove": ["minecraft:diamond"]\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"In the example above, diamonds will be removed from the slot type associated with the item tag and no longer be\nconsidered valid for equipping into that slot type (provided that the slot type itself is using the default behavior of\nvalidating based on item tags)."}),"\n",(0,n.jsx)(t.h2,{id:"validators",children:"Validators"}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["For more precise slot type assignments, validators can be used instead. Validators exist as a field on each slot type\nand consist of an array of ",(0,n.jsx)(t.code,{children:"ResourceLocation"})," entries that refer to predicates registered through\n",(0,n.jsx)(t.code,{children:"CuriosApi#registerPredicate(ResourceLocation, Predicate<SlotResult>)"}),". The field can be changed through slot data files\nin a datapack, as described in the ",(0,n.jsx)(t.a,{href:"/curios/slots/slot-register",children:"slot types page"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"There are three native validators registered by Curios for use:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"curios:all"})," - Returns true for all items (note: ",(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"all"})})," items)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"curios:none"})," - Returns false for all items"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"curios:tag"})," - Returns true for all items in the ",(0,n.jsx)(t.code,{children:"curios:identifier"})," item tag, with ",(0,n.jsx)(t.code,{children:"identifier"})," being the identifier\nof the slot type"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["All ",(0,n.jsx)(t.a,{href:"/curios/slots/preset-slots",children:"preset slot types"})," use ",(0,n.jsx)(t.code,{children:"curios:tag"})," as one of the validators by default, and any slot\ntype that doesn't have any validators defined will automatically initialize with ",(0,n.jsx)(t.code,{children:"curios:tag"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["In order to register a predicate and use a custom validator, developers will need to call\n",(0,n.jsx)(t.code,{children:"CuriosApi#registerPredicate(ResourceLocation, Predicate<SlotResult>)"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'CuriosApi.registerPredicate(new ResourceLocation("examplemod", "my_predicate"), (slotResult) -> {\n  // contents of the predicate here - return true or false    \n});\n'})}),"\n",(0,n.jsx)(t.p,{children:"This can be registered anywhere, but should be done before server loading as that's when the data is needed."}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"SlotResult"})," object used in the predicate is a record consisting of a ",(0,n.jsx)(t.code,{children:"SlotContext"})," and an ",(0,n.jsx)(t.code,{children:"ItemStack"}),". Therefore,\npredicates can return true or false based on either/both the slot context and the item stack involved. However, the\nslot context does not always contain all the information. For example, validating potential slot types while looking\nat an item's tooltip will only pass in the slot identifier and the entity because all other information is not yet\navailable in that case."]})}),"\n",(0,n.jsx)(t.p,{children:"Once a predicate is defined, it can then be referenced in the slot data files:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "validators": ["examplemod:my_predicate"]\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);