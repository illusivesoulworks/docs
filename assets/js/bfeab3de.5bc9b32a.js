"use strict";(self.webpackChunkillusivesoulworks_docs=self.webpackChunkillusivesoulworks_docs||[]).push([[82],{8815:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>d,toc:()=>c});var n=i(5893),r=i(1151),o=i(4866),s=i(5162);const a={sidebar_position:11},l="Slot Modifiers",d={id:"curios/slots/slot-modifiers",title:"Slot Modifiers",description:"A tutorial on how to add and remove slots from the curios inventory on entities.",source:"@site/docs/curios/slots/slot-modifiers.mdx",sourceDirName:"curios/slots",slug:"/curios/slots/slot-modifiers",permalink:"/curios/slots/slot-modifiers",draft:!1,unlisted:!1,editUrl:"https://github.com/illusivesoulworks/docs/edit/main/docs/curios/slots/slot-modifiers.mdx",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"Slot Icon Textures",permalink:"/curios/slots/slot-textures"},next:{title:"Data Generation",permalink:"/curios/slots/data-generation"}},u={},c=[{value:"Overview",id:"overview",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Adding or Removing Slots",id:"adding-or-removing-slots",level:2},{value:"Removing Slot Modifiers",id:"removing-slot-modifiers",level:2},{value:"Items",id:"items",level:2},{value:"Interfaces",id:"interfaces",level:3},{value:"NBT Tag",id:"nbt-tag",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"slot-modifiers",children:"Slot Modifiers"}),"\n",(0,n.jsx)(t.p,{children:"A tutorial on how to add and remove slots from the curios inventory on entities."}),"\n",(0,n.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsxs)(t.p,{children:["Slot modifiers are a way to dynamically add and/or remove slots from entities the same way developers could add and/or\nremove health or attack damage. In fact, it uses the exact same ",(0,n.jsx)(t.code,{children:"AttributeModifier"})," system to accomplish this."]}),"\n",(0,n.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,n.jsxs)(t.p,{children:["The main way to interact with and add slot modifiers is through the ",(0,n.jsx)(t.code,{children:"top.theillusivec4.curios.api.type.capability.ICuriosItemHandler"}),"\ninterface. A developer can grab the specific instance of this on the entity by following the steps from the ",(0,n.jsx)(t.a,{href:"/curios/inventory/basic-inventory",children:"inventory"}),"\nguide to query the capability from Curios."]}),"\n",(0,n.jsx)(t.h2,{id:"adding-or-removing-slots",children:"Adding or Removing Slots"}),"\n",(0,n.jsxs)(t.p,{children:["Adding slots can be done through ",(0,n.jsx)(t.code,{children:"ICuriosItemHandler#addTransientSlotModifiers(Multimap<String, AttributeModifier>)"})," and\n",(0,n.jsx)(t.code,{children:"ICuriosItemHandler#addPermanentSlotModifiers(Multimap<String, AttributeModifier>)"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.strong,{children:"transient"})," slot modifier is a slot modifier that is not serialized to the player data, while a ",(0,n.jsx)(t.strong,{children:"permanent"})," slot\nmodifier is serialized. The former will disappear upon players relogging into a world and the latter will always remain\nuntil manually removed. Transient slot modifiers are often used for effects that may not always be present and need to\nbe verified at certain times while permanent slot modifiers are often used as rewards or other effects that are not\nmeant to be removed often, if ever."]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsx)(t.p,{children:"For slot types that should not appear until given by a relevant slot modifier, be sure to set the default amount of slots\nto 0 so that it does not give any slots by default."})}),"\n",(0,n.jsx)(t.p,{children:"An example of adding a transient slot modifier:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'CuriosApi.getCuriosInventory(livingEntity).ifPresent(inventory -> {\n    inventory.addTransientSlotModifier("ring", uuid, "name", 2, AttributeModifier.Operation.ADDITION));\n});\n'})}),"\n",(0,n.jsxs)(t.p,{children:["This will add 2 slots to the ",(0,n.jsx)(t.code,{children:"ring"})," slot type, with the specified ",(0,n.jsx)(t.code,{children:"name"})," and ",(0,n.jsx)(t.code,{children:"uuid"})," (UUID is not provided so developers\nwill need to generate or substitute one). Note that each key for the map must be a valid ",(0,n.jsx)(t.code,{children:"SlotType"})," identifier, such as\n",(0,n.jsx)(t.code,{children:'"ring"'})," or ",(0,n.jsx)(t.code,{children:'"necklace"'}),"."]}),"\n",(0,n.jsx)(t.p,{children:"In the case of adding multiple slot modifiers at once:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'CuriosApi.getCuriosInventory(livingEntity).ifPresent(inventory -> {\n    Map<String, AttributeModifier> map = LinkedHashMultimap.create();\n    map.put("ring", new AttributeModifier(uuid, "name", 2, AttributeModifier.Operation.ADDITION));\n    map.put("necklace", new AttributeModifier(uuid, "name", 1, AttributeModifier.Operation.ADDITION));\n    inventory.addTransientSlotModifiers(map);\n});\n'})}),"\n",(0,n.jsxs)(t.p,{children:["If slots need to be ",(0,n.jsx)(t.strong,{children:"removed"}),", this is as simple as stating a negative amount for an ",(0,n.jsx)(t.code,{children:"AttributeModifier.Operation.ADDITION"}),"\noperation in the ",(0,n.jsx)(t.code,{children:"AttributeModifier"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'inventory.addTransientSlotModifier("ring", uuid, "name", -2, AttributeModifier.Operation.ADDITION));\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Instead of adding 2 slots, this will ",(0,n.jsx)(t.strong,{children:"remove"})," 2 slots."]}),"\n",(0,n.jsx)(t.p,{children:"If the total slot amount results in a number less than 0, the slots will remain at 0 but the slot modifiers will remain\nand existing slot modifiers will stack with each other. If a slot modifier removes 2 slots and the base amount is\nalready 0, there will seemingly be no effect. However, if another slot modifier adds 3 slots on top of that, it will add\nto the existing -2 and result in a total of 1 slot."}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["Slot modifiers can only add slots for slot types that are already assigned to entities. If a slot type exists but is not\nassigned to the specified entity, then the slot modifier will not be able to add any slots of that slot type. Be sure to\ngo over ",(0,n.jsx)(t.a,{href:"./entity-register",children:"how to assign slots to entities"})," if slot modifiers do not appear to be adding any slots."]})}),"\n",(0,n.jsx)(t.h2,{id:"removing-slot-modifiers",children:"Removing Slot Modifiers"}),"\n",(0,n.jsxs)(t.p,{children:["Removing slot modifiers can be done through ",(0,n.jsx)(t.code,{children:"ICuriosItemHandler#removeSlotModifiers(Multimap<String, AttributeModifier>)"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"This follows very similar logic as the preceding section on adding slot modifiers:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'CuriosApi.getCuriosInventory(livingEntity).ifPresent(inventory -> {\n    inventory.removeSlotModifier("ring", uuid);\n})\n'})}),"\n",(0,n.jsxs)(t.p,{children:["This will remove the slot modifier with UUID ",(0,n.jsx)(t.code,{children:"uuid"})," from the ",(0,n.jsx)(t.code,{children:"ring"})," slot type."]}),"\n",(0,n.jsx)(t.p,{children:"In the case of removing multiple slot modifiers at once:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'CuriosApi.getCuriosInventory(livingEntity).ifPresent(inventory -> {\n    Map<String, AttributeModifier> map = LinkedHashMultimap.create();\n    map.put("ring", new AttributeModifier(uuid, "name", 2, AttributeModifier.Operation.ADDITION));\n    inventory.removeSlotModifiers(map);\n})\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"AttributeModifier"})," used is mostly filler, the amount and operation do not matter. The key and the ",(0,n.jsx)(t.code,{children:"uuid"}),", however,\nmust match the ones used for the slot modifier being removed."]}),"\n",(0,n.jsx)(t.h2,{id:"items",children:"Items"}),"\n",(0,n.jsx)(t.p,{children:"The methods above are helpful for universal applications, but there are more streamlined methods for developers that\nwant to attach slot modifiers to specific items so that they are only applied when those items are equipped and then\nremoved when unequipped."}),"\n",(0,n.jsx)(t.h3,{id:"interfaces",children:"Interfaces"}),"\n",(0,n.jsxs)(t.p,{children:["Both the ",(0,n.jsx)(t.code,{children:"ICurio"})," and ",(0,n.jsx)(t.code,{children:"ICurioItem"})," interfaces expose a method called ",(0,n.jsx)(t.code,{children:"getAttributeModifiers"})," that returns a\n",(0,n.jsx)(t.code,{children:"Multimap<Attribute, AttributeModifier>"})," denoting attributes and their modifiers, in the same way that items themselves\nhave a similar method when equipped in vanilla slots. For more information on attaching these interfaces to items, see\nthe ",(0,n.jsx)(t.a,{href:"../items/curio-creation",children:"curio creation page"}),"."]}),"\n",(0,n.jsxs)(o.Z,{groupId:"curiointerface",children:[(0,n.jsx)(s.Z,{value:"curio",label:"ICurio",default:!0,children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"@Override\npublic Multimap<Attribute, AttributeModifier> getAttributeModifiers(SlotContext slotContext, UUID uuid) {\n    Multimap<Attribute, AttributeModifier> map = LinkedHashMultimap.create();\n    // Add attribute modifiers\n    return map;\n}\n"})})}),(0,n.jsx)(s.Z,{value:"curioitem",label:"ICurioItem",default:!0,children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"@Override\npublic Multimap<Attribute, AttributeModifier> getAttributeModifiers(SlotContext slotContext, UUID uuid, ItemStack stack) {\n    Multimap<Attribute, AttributeModifier> map = LinkedHashMultimap.create();\n    // Add attribute modifiers\n    return map;\n}\n"})})})]}),"\n",(0,n.jsxs)(t.p,{children:["In order to add ",(0,n.jsx)(t.strong,{children:"slot"})," modifiers specifically, developers can leverage the\n",(0,n.jsx)(t.code,{children:"CuriosApi#addSlotModifier(Multimap, String, UUID, double, AttributeModifier.Operation)"})," method:"]}),"\n",(0,n.jsxs)(o.Z,{groupId:"curiointerface",children:[(0,n.jsx)(s.Z,{value:"curio",label:"ICurio",default:!0,children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'@Override\npublic Multimap<Attribute, AttributeModifier> getAttributeModifiers(SlotContext slotContext, UUID uuid) {\n    Multimap<Attribute, AttributeModifier> map = LinkedHashMultimap.create();\n    CuriosApi.addSlotModifier(map, "ring", uuid, 2, AttributeModifier.Operation.ADDITION);\n    return map;\n}\n'})})}),(0,n.jsx)(s.Z,{value:"curioitem",label:"ICurioItem",default:!0,children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'@Override\npublic Multimap<Attribute, AttributeModifier> getAttributeModifiers(SlotContext slotContext, UUID uuid, ItemStack stack) {\n    Multimap<Attribute, AttributeModifier> map = LinkedHashMultimap.create();\n    CuriosApi.addSlotModifier(map, "ring", uuid, 2, AttributeModifier.Operation.ADDITION);\n    return map;\n}\n'})})})]}),"\n",(0,n.jsxs)(t.p,{children:["This will add 2 slots of the ",(0,n.jsx)(t.code,{children:"ring"})," slot type using the passed in ",(0,n.jsx)(t.code,{children:"uuid"})," from the second parameter of the method. The\nslots will only be added when this item is equipped and those slots will be removed when this item is unequipped."]}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["Although the ",(0,n.jsx)(t.code,{children:"uuid"})," in the preceding section can be decided on a case-by-case basis, the ",(0,n.jsx)(t.code,{children:"uuid"})," in this section related\nto items is ",(0,n.jsx)(t.strong,{children:"strongly encouraged"})," to be fed from the second parameter of the ",(0,n.jsx)(t.code,{children:"getAttributeModifiers"})," method. This is\nbecause the UUID in the parameter is guaranteed to be slot-specific, which avoids any collision issues in case multiple\ninstances of the same item are equipped."]})}),"\n",(0,n.jsx)(t.h3,{id:"nbt-tag",children:"NBT Tag"}),"\n",(0,n.jsx)(t.p,{children:"The previous method works for items that developers can directly register or implement interfaces or capabilities for,\nbut this can fall short if developers want to add these modifiers dynamically or even override previously registered\nbehavior."}),"\n",(0,n.jsxs)(t.p,{children:["As an alternative, developers can directly add slot modifiers to item NBT tags as well using ",(0,n.jsx)(t.code,{children:"CuriosApi#addSlotModifier(ItemStack, String, String, UUID, double, AttributeModifier.Operation, String)"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:'CuriosApi.addSlotModifier(stack, "ring", "name", uuid, 2, AttributeModifier.Operation.ADDITION, "necklace");\n'})}),"\n",(0,n.jsxs)(t.p,{children:["There are two slot identifiers in this method. The first one, ",(0,n.jsx)(t.code,{children:'"ring"'})," above, denotes the slot type that the slot modifier\ngives or removes slots from. The second one, ",(0,n.jsx)(t.code,{children:'"necklace"'})," above, denotes the slot type that the slot modifier becomes\nactive in. In other words, the above example will give 2 ",(0,n.jsx)(t.code,{children:"ring"})," slots when the item is equipped in a ",(0,n.jsx)(t.code,{children:"necklace"})," slot."]}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["It's usually best to use ",(0,n.jsx)(t.code,{children:"null"})," in place of the ",(0,n.jsx)(t.code,{children:"uuid"}),", to avoid collisions as described in the preceding caution note,\nunless there is justification for providing a static UUID. Providing a ",(0,n.jsx)(t.code,{children:"null"})," UUID will allow Curios to provide a\nslot-specific UUID in its place."]})})]})}function m(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},5162:(e,t,i)=>{i.d(t,{Z:()=>s});i(7294);var n=i(512);const r={tabItem:"tabItem_Ymn6"};var o=i(5893);function s(e){let{children:t,hidden:i,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,n.Z)(r.tabItem,s),hidden:i,children:t})}},4866:(e,t,i)=>{i.d(t,{Z:()=>I});var n=i(7294),r=i(512),o=i(2466),s=i(6550),a=i(469),l=i(1980),d=i(7392),u=i(12);function c(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:i}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return c(e).map((e=>{let{props:{value:t,label:i,attributes:n,default:r}}=e;return{value:t,label:i,attributes:n,default:r}}))}(i);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,i])}function m(e){let{value:t,tabValues:i}=e;return i.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:i}=e;const r=(0,s.k6)(),o=function(e){let{queryString:t=!1,groupId:i}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:t,groupId:i});return[(0,l._X)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function f(e){const{defaultValue:t,queryString:i=!1,groupId:r}=e,o=h(e),[s,l]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=i.find((e=>e.default))??i[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:o}))),[d,c]=p({queryString:i,groupId:r}),[f,v]=function(e){let{groupId:t}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,u.Nk)(i);return[r,(0,n.useCallback)((e=>{i&&o.set(e)}),[i,o])]}({groupId:r}),g=(()=>{const e=d??f;return m({value:e,tabValues:o})?e:null})();(0,a.Z)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),v(e)}),[c,v,o]),tabValues:o}}var v=i(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=i(5893);function x(e){let{className:t,block:i,selectedValue:n,selectValue:s,tabValues:a}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.o5)(),u=e=>{const t=e.currentTarget,i=l.indexOf(t),r=a[i].value;r!==n&&(d(t),s(r))},c=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;t=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;t=l[i]??l[l.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":i},t),children:a.map((e=>{let{value:t,label:i,attributes:o}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>l.push(e),onKeyDown:c,onClick:u,...o,className:(0,r.Z)("tabs__item",g.tabItem,o?.className,{"tabs__item--active":n===t}),children:i??t},t)}))})}function j(e){let{lazy:t,children:i,selectedValue:r}=e;const o=(Array.isArray(i)?i:[i]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function y(e){const t=f(e);return(0,b.jsxs)("div",{className:(0,r.Z)("tabs-container",g.tabList),children:[(0,b.jsx)(x,{...e,...t}),(0,b.jsx)(j,{...e,...t})]})}function I(e){const t=(0,v.Z)();return(0,b.jsx)(y,{...e,children:c(e.children)},String(t))}},1151:(e,t,i)=>{i.d(t,{Z:()=>a,a:()=>s});var n=i(7294);const r={},o=n.createContext(r);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);